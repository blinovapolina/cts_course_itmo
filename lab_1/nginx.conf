# Первый pet проект - VPN сервис
# Виртуальный хост для VPN сервиса на домене vpn.test.com
server {
    # Слушаем порт 443 с поддержкой SSL/TLS для безопасного HTTPS соединения
    listen 443 ssl;

    # Путь к SSL сертификату для домена test.com
    ssl_certificate /var/www/certificates/test.com/cert.crt;
    # Путь к приватному ключу SSL сертификата
    ssl_certificate_key /var/www/certificates/test.com/cert.key;

    # Имя сервера - домен, для которого работает этот виртуальный хост
    server_name vpn.test.com;

    # Основной location блок - обрабатывает все запросы к корню сайта
    location / {
        # Устанавливаем версию HTTP протокола для проксирования
        proxy_http_version 1.1;
        # Подключаем стандартные параметры uWSGI
        include uwsgi_params;

        # Отключаем автоматическое перенаправление от прокси-сервера
        proxy_redirect off;
        # Отключаем буферизацию для реального времени
        proxy_buffering off;
        # Передаем оригинальный Host заголовок
        proxy_set_header Host $host;
        # Обходим кеш при WebSocket соединениях
        proxy_cache_bypass $http_upgrade;
        # Настраиваем заголовки для WebSocket соединений
        proxy_set_header Connection 'upgrade';
        proxy_set_header Upgrade $http_upgrade;
        # Передаем реальный IP адрес клиента
        proxy_set_header X-Real-IP $remote_addr;
        # Передаем информацию о протоколе (https)
        proxy_set_header X-Forwarded-Proto $scheme;
        # Передаем цепочку IP адресов через прокси
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

        # Проксируем запросы на локальный VPN сервис на порту 8000
        proxy_pass http://127.0.0.1:8000;
    }
}

# Второй pet проект - Блог сервис
# Виртуальный хост для блог сервиса на домене blog.test.com
server {
    # Слушаем порт 443 с поддержкой SSL/TLS для безопасного HTTPS соединения
    listen 443 ssl;

    # Путь к SSL сертификату для домена test.com (общий сертификат)
    ssl_certificate /var/www/certificates/test.com/cert.crt;
    # Путь к приватному ключу SSL сертификата
    ssl_certificate_key /var/www/certificates/test.com/cert.key;

    # Имя сервера - домен, для которого работает этот виртуальный хост
    server_name blog.test.com;

    # Использование alias для статических файлов блога
    # Псевдоним пути /static указывает на реальную папку со статическими файлами
    location /static {
        # Создаем псевдоним: запросы к /static/* будут обрабатываться из указанной папки
        alias /var/www/pet-projects/blog-service/static/;
        # Устанавливаем срок кеширования статических файлов на 1 год
        expires 1y;
        # Добавляем заголовки кеширования для браузеров
        add_header Cache-Control "public, immutable";
    }

    # Использование alias для медиа файлов блога
    # Псевдоним пути /media указывает на папку с загруженными файлами
    location /media {
        # Создаем псевдоним: запросы к /media/* будут обрабатываться из указанной папки
        alias /var/www/pet-projects/blog-service/media/;
        # Устанавливаем срок кеширования медиа файлов на 1 месяц
        expires 1M;
        # Добавляем заголовки кеширования для браузеров
        add_header Cache-Control "public";
    }

    # Использование alias для админ панели блога
    # Псевдоним пути /admin-panel указывает на папку с админ интерфейсом
    location /admin-panel {
        # Создаем псевдоним: запросы к /admin-panel/* будут обрабатываться из указанной папки
        alias /var/www/pet-projects/blog-service/admin/;
        # Пытаемся найти файл, если не найден - переходим к прокси
        try_files $uri $uri/ @blog_proxy;
    }

    # Основной location блок - обрабатывает все остальные запросы к блогу
    location / {
        # Пытаемся найти статический файл, если не найден - переходим к прокси
        try_files $uri $uri/ @blog_proxy;
    }

    # Внутренний location для проксирования запросов к блог сервису
    location @blog_proxy {
        # Устанавливаем версию HTTP протокола для проксирования
        proxy_http_version 1.1;
        # Подключаем стандартные параметры uWSGI
        include uwsgi_params;

        # Отключаем автоматическое перенаправление от прокси-сервера
        proxy_redirect off;
        # Отключаем буферизацию для реального времени
        proxy_buffering off;
        # Передаем оригинальный Host заголовок
        proxy_set_header Host $host;
        # Обходим кеш при WebSocket соединениях
        proxy_cache_bypass $http_upgrade;
        # Настраиваем заголовки для WebSocket соединений
        proxy_set_header Connection 'upgrade';
        proxy_set_header Upgrade $http_upgrade;
        # Передаем реальный IP адрес клиента
        proxy_set_header X-Real-IP $remote_addr;
        # Передаем информацию о протоколе (https)
        proxy_set_header X-Forwarded-Proto $scheme;
        # Передаем цепочку IP адресов через прокси
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

        # Проксируем запросы на локальный блог сервис на порту 8001
        proxy_pass http://127.0.0.1:8001;
    }
}

# Перенаправление HTTP на HTTPS для VPN сервиса
# Виртуальный хост для обработки HTTP запросов (порт 80) к VPN сервису
server {
    # Слушаем порт 80 для HTTP запросов
    listen 80;
    # Имя сервера - домен VPN сервиса
    server_name vpn.test.com;
    # Специальная проверка для основного домена test.com
    if ($host = test.com) { return 301 https://www.$host$request_uri; }
    # Принудительное перенаправление всех HTTP запросов на HTTPS
    return 301 https://$host$request_uri;
}

# Перенаправление HTTP на HTTPS для блог сервиса
# Виртуальный хост для обработки HTTP запросов (порт 80) к блог сервису
server {
    # Слушаем порт 80 для HTTP запросов
    listen 80;
    # Имя сервера - домен блог сервиса
    server_name blog.test.com;
    # Специальная проверка для основного домена test.com
    if ($host = test.com) { return 301 https://www.$host$request_uri; }
    # Принудительное перенаправление всех HTTP запросов на HTTPS
    return 301 https://$host$request_uri;
}
